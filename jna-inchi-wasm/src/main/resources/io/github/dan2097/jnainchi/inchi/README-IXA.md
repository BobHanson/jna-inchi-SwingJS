# jna-inchi-ixa

This Maven module contains two Java classes, InchiAPI and IXA.

These two classes carry out the same roles as JnaInchi and IxaFunctions. That is, InchiAPI is the public class called by any Java program using the IXA interface, and IXA does a bit of wrapping of the native calls.

The difference is that InchiAPI restricts itself to inchi C's libinchi/IXA* functions (primarily), whereas JnaInchi does not. This is because (a) we really want people using the InChI Extended API, and (b) these functions do not require the other end of the operation (Java or JavaScript) to have to deal with architectures, number byte length, and structure byte alignments. This is something JNA is built to handle, but (currently) JavaScript cannot accommodate.

The reason we are talking at all about JavaScript here is that SwingJS implements Java native calls to C as calls to WASM in JavaScript (see below). 

Note also that, unlike JnaInchi/IxaFunctions, InchiAPI and IXA do not create an additional layer between com.sun.jna and the inchi world involving subclassed Pointer. Instead, we just use Pointer here. This is possible because none of the native functions implmented deliver pointers to C structures that need to be translated into Java. The memory pointers to structures returned by inchi C are only used as parameters back into the interface. (Pointers to string, int, and boolean are handled internally by the Emscripten code built into jnainchi.js; and "pointers" that inchi C uses to deliver integer values (such as the return for IXA\_MOL\_CreateAtom) are not actually memory pointers at all. They just use the address field for their value. They are not actually treated as pointers by Emscripten, just as wrapped numbers, similar to the way Java Integer wraps an int.

# jna-inchi-wasm

This Maven module contains the wasm-related code created from InChI C using the emscripten compiler. Two additional files are found here, jnainchi.js and jnainchi.wasm.

These files are created automatically from a makefile that runs the emcc compiler and LLVM linker. In order to be recognized and processed automatically by the SwingJS runtime library, they must be in the same directory as InchiLibrary.java and bear the same name as given the statement in InchiLibary's native registration:

   public static final String JNA_LIBRARY_NAME = "jnainchi";
   public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(InchiLibrary.JNA_LIBRARY_NAME);
   static { 
        Native.register(InchiLibrary.class, InchiLibrary.JNA_NATIVE_LIB); 
   }

When that is the case, the SwingJS run-time will catch the Native.register command and invoke the SwingJS WASM loader, Clazz._loadWasm(). This will replace all of the (empty) native Java methods such as 

   static native Pointer IXA_MOL_Create(Pointer hStatus);

with JavaScript code that turns them into WASM cwrap wrapped ccall invocations in JavaScript. Calls then from JavaScript can be made directly to InchiLibrary. For convenience, the IXA class, similar to IxaFunctions, provides a public interface to the package-privage native methods in jnainchi/inchi/. 

Note that commands that involve inchi C "tag" parameter types, such as

 public static native int GetStructFromINCHI(tagINCHI_InputINCHI inpInChI, tagINCHI_OutputStruct outStruct);

are not supported in InchiAPI, because though they can be used in JNA, they there is no JavaScript equivalent for them. 

# wasm creation

InChI WASM code is from the InChI-SwingJS project, generated by the INCHI\_WEB\_JNA/makefile after updating the inchi C code from the InChI project.

Note that while there may be an inchi-web-jna.c file compiled, it is only for testing; no code in that file is called by InchiAPI.

This makefile differs from the INCHI\_WEB\_DEMO makefile only in that it includes the list of IXA methods in libinchi/, and it identifies the product module by the same name as Java registration does its JAR resources, namely "jnainchi". 

# demonstration

A demonstration of this interface can be seen at https://chemapps/stolaf/edu/inchi/cdk-web-demo, with more (simpler!) demonstrations to follow. 
